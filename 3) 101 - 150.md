Задание: 101 (qwrqwr: 2013-03-29)
Таблица Printer сортируется по возрастанию поля code.
Упорядоченные строки составляют группы: первая группа начинается с первой строки, каждая строка со значением color='n' начинает новую группу, группы строк не перекрываются.
Для каждой группы определить: наибольшее значение поля model (max_model), количество уникальных типов принтеров (distinct_types_cou) и среднюю цену (avg_price).
Для всех строк таблицы вывести: code, model, color, type, price, max_model, distinct_types_cou, avg_price.
```sh
WITH grouped AS (
SELECT code, model, color, type, price, CASE WHEN MAX(CASE WHEN p.color = 'n' THEN p.code END) OVER(ORDER BY p.code) IS NULL THEN 0 ELSE MAX(CASE WHEN p.color = 'n' THEN p.code END) OVER(ORDER BY p.code) END AS grp FROM Printer p
)
select code, model, color, type, price, MAX(model) OVER(PARTITION BY G.grp) AS max_model, d.dist_type,
	AVG(price) OVER(PARTITION BY G.grp) AS avg_price FROM grouped G
	JOIN ( SELECT g2.grp, COUNT(distinct g2.type) as dist_type FROM grouped g2 GROUP BY g2.grp) AS d ON G.grp = d.grp
```
Задание: 102 (Serge I: 2003-04-29)
Определить имена разных пассажиров, которые летали
только между двумя городами (туда и/или обратно).
```sh
WITH trip_swapped AS
(
	SELECT trip_no, id_comp, plane, 
	CASE WHEN town_from > town_to THEN town_to ELSE town_from END as s_town_from, 
	CASE WHEN town_from > town_to THEN town_from ELSE town_to END AS s_town_to, 
	town_from, town_to FROM Trip
)
SELECT  p.name FROM Passenger p JOIN Pass_in_trip pit ON p.ID_psg = pit.id_psg
JOIN trip_swapped AS t ON pit.trip_no = t.trip_no
WHERE NOT EXISTS
(
	SELECT NULL FROM Pass_in_trip pit2 JOIN trip_swapped t2 ON pit2.trip_no = t2.trip_no
	WHERE 
		pit2.id_psg = pit.id_psg AND
		pit2.trip_no <> pit.trip_no AND
		(t.s_town_from <> t2.s_town_from OR t.s_town_to <> t2.s_town_to)
)
GROUP BY p.id_psg, p.name
```
Задание: 103 (qwrqwr: 2013-05-17)
Выбрать три наименьших и три наибольших номера рейса. Вывести их в шести столбцах одной строки, расположив в порядке от наименьшего к наибольшему.
Замечание: считать, что таблица Trip содержит не менее шести строк.
```sh
with cte as
(
Select trip_no, row_number() over(order by trip_no asc) as rn_asc, row_number() over(order by trip_no desc) as rn_desc
from trip),
mins_n_maxs as
(
 select trip_no, row_number() over(order by trip_no asc) as rn from cte where rn_asc <= 3 or rn_desc <=3
)
select * from mins_n_maxs
PIVOT
(
 MIN(trip_no) FOR rn IN ([1], [2], [3], [4], [5], [6])
) as x
```
Задание: 104 (Serge I: 2013-07-19)
Для каждого класса крейсеров, число орудий которого известно, пронумеровать (последовательно от единицы) все орудия.
Вывод: имя класса, номер орудия в формате 'bc-N'.
```sh
with nums1 as (select 1 as n from (values(1), (1)) as c(n)),
nums2 as (select 1 as n from nums1 n1 cross join nums1 n2),
nums3 as (select 1 as n from nums2 n1 cross join nums2 n2),
rn as (select row_number() over(order by (select null)) as num
from nums3)

select class, 'bc-'+cast(rn.num as varchar) from classes join rn on numGuns >= rn.num
where type ='bc'
```
Задание: 105 (qwrqwr: 2013-09-11)
Статистики Алиса, Белла, Вика и Галина нумеруют строки у таблицы Product.
Все четверо упорядочили строки таблицы по возрастанию названий производителей.
Алиса присваивает новый номер каждой строке, строки одного производителя она упорядочивает по номеру модели.
Трое остальных присваивают один и тот же номер всем строкам одного производителя.
Белла присваивает номера начиная с единицы, каждый следующий производитель увеличивает номер на 1.
У Вики каждый следующий производитель получает такой же номер, какой получила бы первая модель этого производителя у Алисы.
Галина присваивает каждому следующему производителю тот же номер, который получила бы его последняя модель у Алисы.
Вывести: maker, model, номера строк получившиеся у Алисы, Беллы, Вики и Галины соответственно.
```sh
SELECT maker, model,
ROW_NUMBER() OVER(ORDER BY maker, model) AS [Alice],
DENSE_RANK() OVER(ORDER BY maker) AS [Betty],
RANK() OVER(ORDER BY maker) AS [Carol],
COUNT(*) OVER (ORDER BY maker RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS [Diana]
FROM Product p1
```
Задание: 106 (Baser: 2013-09-06)
Пусть v1, v2, v3, v4, ... представляет последовательность вещественных чисел - объемов окрасок b_vol, упорядоченных по возрастанию b_datetime, b_q_id, b_v_id.
Найти преобразованную последовательность P1=v1, P2=v1/v2, P3=v1/v2*v3, P4=v1/v2*v3/v4, ..., где каждый следующий член получается из предыдущего умножением на vi (при нечетных i) или делением на vi (при четных i).
Результаты представить в виде b_datetime, b_q_id, b_v_id, b_vol, Pi, где Pi - член последовательности, соответствующий номеру записи i. Вывести Pi с 8-ю знаками после запятой.
```sh
WITH a AS(
    SELECT
        *,
        row_number() over(
            ORDER BY
                b_datetime,
                b_q_id,
                b_v_id
        ) n
    FROM
        utb
)
SELECT
    b_datetime,
    b_q_id,
    b_v_id,
    b_vol,
    cast(exp(sm1) / exp(sm2) AS numeric(12, 8)) k
FROM
    a x
    CROSS APPLY (
        SELECT
            sum(iif(n % 2 <> 0, log(b_vol), 0)) sm1,
            sum(iif(n % 2 = 0, log(b_vol), 0)) sm2
        FROM
            a
        WHERE
            n <= x.n
    ) y
```
Задание: 107 (VIG: 2003-09-01)
Для пятого по счету пассажира из числа вылетевших из Ростова в апреле 2003 года определить компанию, номер рейса и дату вылета.
Замечание. Считать, что два рейса одновременно вылететь из Ростова не могут.
```sh
Select c.name, t.trip_no, pit.date from company c inner join trip t on c.id_comp = t.id_comp left join pass_in_trip pit on t.trip_no = pit.trip_no
where pit.date between '20030401' and '20030430'
and t.town_from = 'Rostov'
order by pit.date asc, t.time_out
offset 4 rows fetch next 1 row only
```
Задание: 108 (Baser: 2013-10-16)
Реставрация экспонатов секции "Треугольники" музея ПФАН проводилась согласно техническому заданию. Для каждой записи таблицы utb малярами подкрашивалась сторона любой фигуры, если длина этой стороны равнялась b_vol.
Найти окрашенные со всех сторон треугольники, кроме равносторонних, равнобедренных и тупоугольных.
Для каждого треугольника (но без повторений) вывести три значения X, Y, Z, где X - меньшая, Y - средняя, а Z - большая сторона.
```sh
SELECT
    DISTINCT b1.B_VOL,
    b2.b_vol,
    b3.b_vol
FROM
    utb b1,
    utb b2,
    utb b3
WHERE
    b1.B_VOL < b2.B_VOL
    AND b2.B_VOL < b3.B_VOL
    AND NOT (
        b3.B_VOL > SQRT(SQUARE(b1.B_VOL) + SQUARE(b2.B_VOL))
    )
```
Задание: 109 (qwrqwr: 2011-01-13)
Вывести:
1. Названия всех квадратов черного или белого цвета.
2. Общее количество белых квадратов.
3. Общее количество черных квадратов.
```sh
WITH squares AS (
SELECT q.Q_NAME, SUM(b.B_VOL) AS all_sum_white, COUNT(CASE WHEN b.B_Q_ID IS NULL THEN 1 END) AS all_black FROM utQ q LEFT JOIN utB b ON q.Q_ID = b.B_Q_ID
GROUP BY q.Q_ID, q.Q_NAME
)
SELECT s.Q_NAME, COUNT(s.all_sum_white) OVER(), SUM(s.all_black) OVER() FROM squares s 
WHERE s.all_sum_white = 765 OR s.all_sum_white IS NULL
```
Задание: 110 (Serge I: 2003-12-24)
Определить имена разных пассажиров, когда-либо летевших рейсом, который вылетел в субботу, а приземлился в воскресенье.
```sh
select p.name from trip t inner join pass_in_trip pit on pit.trip_no = t.trip_no inner join passenger p on p.id_psg = pit.id_psg where DATEPART(weekday, pit.date) = 7 and CAST(t.time_out as time) > CAST(t.time_in as time)
group by p.id_psg, p.name
```
Задание: 111 (Serge I: 2003-12-24)
Найти НЕ белые и НЕ черные квадраты, которые окрашены разными цветами в пропорции 1:1:1. Вывод: имя квадрата, количество краски одного цвета
```sh
WITH aggregates AS
(
	SELECT q.Q_NAME, v.V_COLOR, SUM(b.B_VOL) AS overall FROM utB b JOIN utV v ON b.B_V_ID = v.V_ID JOIN utQ q ON q.Q_ID = b.B_Q_ID
	GROUP BY q.Q_ID, q.Q_NAME, v.V_COLOR
)
SELECT a.Q_NAME, MAX(a.overall) FROM aggregates a
GROUP BY a.Q_NAME
HAVING COUNT(*) = 3 AND MIN(a.overall) <> 255 AND MIN(a.overall) = MAX(a.overall)
```
Задание: 112 (Serge I: 2003-12-24)
Какое максимальное количество черных квадратов можно было бы окрасить в белый цвет
оставшейся краской
```sh
With q As (select V_COLOR, V_ID, 
CASE 
WHEN SUM(B_VOL) IS NULL 
THEN 255 
ELSE 255-SUM(B_VOL) 
END RemainPaint 
from utB right join utV on B_V_ID = V_ID 
group by V_COLOR, V_ID) 
Select iif(count(*)=3, min(r),0) Qty 
from (Select SUM(RemainPaint)/255 r from q  
Group by V_color) w
```
Задание: 113 (Serge I: 2003-12-24)
Сколько каждой краски понадобится, чтобы докрасить все Не белые квадраты до белого цвета.
Вывод: количество каждой краски в порядке (R,G,B)
```sh
WITH all_cols AS
(
	SELECT * FROM utQ q	CROSS JOIN (SELECT 'R' AS Color
	UNION ALL
	SELECT 'B'
	UNION ALL
	SELECT 'G') AS cj
), STATEMENT AS
(
	SELECT q.Q_NAME, q.Color, SUM(ISNULL(b.B_VOL, 0)) AS vol FROM utB b JOIN utV v ON
	b.B_V_ID = v.V_ID RIGHT JOIN all_cols q ON q.Q_ID = b.B_Q_ID AND q.Color = v.V_COLOR
	GROUP BY q.Q_NAME, q.Color
)
SELECT SUM(CASE WHEN s.Color = 'R' THEN 255 - s.vol END) AS [Red],
SUM(CASE WHEN s.Color = 'G' THEN 255 - s.vol END) AS [Green],
SUM(CASE WHEN s.Color = 'B' THEN 255 - s.vol END) AS [Blue]
FROM STATEMENT s
```
Задание: 114 (Serge I: 2003-04-08)
Определить имена разных пассажиров, которым чаще других доводилось лететь на одном и том же месте. Вывод: имя и количество полетов на одном и том же месте.
```sh
select p.name, tt.dr from (
	select TOP 1 WITH TIES t.id_psg, max(t.n) as dr FROM
		(
		SELECT id_psg, place, COUNT(*) n
		FROM pass_in_trip
		GROUP BY id_psg, place
		) t
        group by t.id_psg
        order by max(t.n) desc
) tt
inner join passenger p on p.id_psg = tt.id_psg
```
Задание: 115 (Baser: 2013-11-01)
Рассмотрим равнобочные трапеции, в каждую из которых можно вписать касающуюся всех сторон окружность. Кроме того, каждая сторона имеет целочисленную длину из множества значений b_vol.
Вывести результат в 4 колонки: Up, Down, Side, Rad. Здесь Up - меньшее основание, Down - большее основание, Side - длины боковых сторон, Rad – радиус вписанной окружности (с 2-мя знаками после запятой).
```sh
SELECT
    DISTINCT Up = u.b_vol,
    Down = d.b_vol,
    Side = s.b_vol,
    Rad = cast(
        POWER(
            (
                POWER(s.b_vol, 2) - POWER((1.* d.b_vol -1.* u.b_vol) / 2, 2)
            ),
            1./ 2.
        ) / 2 AS dec(15, 2)
    )
FROM
    utB u,
    utB d,
    utB s
WHERE
    u.b_vol < d.b_vol
    AND 1.* u.b_vol + 1.* d.b_vol = 2.* s.b_vol
```
Задание: 116 (Velmont: 2013-11-19)
Считая, что каждая окраска длится ровно секунду, определить непрерывные интервалы времени с длительностью более 1 секунды из таблицы utB.
Вывод: дата первой окраски в интервале, дата последней окраски в интервале.
```sh
with distinct_vals as
(
select b_datetime from utB group by b_datetime
)
,intervals as 
(
 select distinct b_datetime, dateadd(second, -row_number() over(order by b_datetime asc), b_datetime) as nxt from distinct_vals 
)select min(b_datetime), max(b_datetime) from intervals
group by nxt having count(*) > 1
```
Задание: 117 (Serge I: 2013-11-29)
По таблице Classes для каждой страны найти максимальное значение среди трех выражений:
numguns*5000, bore*3000, displacement.
Вывод в три столбца:
- страна;
- максимальное значение;
- слово `numguns` - если максимум достигается для numguns*5000, слово `bore` - если максимум достигается для bore*3000, слово `displacement` - если максимум достигается для displacement.
Замечание. Если максимум достигается для нескольких выражений, выводить каждое из них отдельной строкой.
```sh
SELECT Top 1 WIth ties country, value, name
FROM Classes
CROSS APPLY
(
VALUES
('numGuns', numGuns*5000)
,
('bore', bore*3000)
,
('displacement', displacement)
)
AS spec(name, value)
Group BY country, name, value
order by rank()over(partition by country order by value desc)
```
Задание: 118 (qwrqwr: 2013-12-11)
Выборы Директора музея ПФАН проводятся только в високосный год, в первый вторник апреля после первого понедельника апреля.
Для каждой даты из таблицы Battles определить дату ближайших (после этой даты) выборов Директора музея ПФАН.
Вывод: сражение, дата сражения, дата выборов. Даты выводить в формате "yyyy-mm-dd".
```sh
WITH min_max_dts AS
(
	SELECT MIN(b.date) AS min_date, MAX(b.date) AS max_date FROM Battles b
),
nums1 AS (SELECT 1 AS n FROM (VALUES(1), (1), (1), (1)) AS d(n)),
nums2 AS (SELECT 1 AS n FROM nums1 n1 CROSS JOIN nums1 n2),
nums3 AS (SELECT 1 AS n FROM nums2 n1 CROSS JOIN nums2 n2),
nums AS (SELECT ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS num FROM nums3),
gen_nums AS (SELECT n.num FROM nums n JOIN min_max_dts mmd ON n.num <= YEAR(mmd.max_date) - YEAR(mmd.min_date) + 4),
leap_years AS (
	SELECT mmd.min_date, gn1.num - 1 AS num FROM min_max_dts mmd
	JOIN gen_nums gn1 ON (YEAR(mmd.min_date) + gn1.num - 1) % 4 = 0 AND (NOT ((YEAR(mmd.min_date) + gn1.num - 1) % 100 = 0)) OR ((YEAR(mmd.min_date) + gn1.num - 1) % 400 = 0) 
), days AS
( SELECT *, DATEFROMPARTS(YEAR(mmd.min_date) + mmd.num, 4, gn2.numeq) AS dtfromparts FROM leap_years mmd
	CROSS APPLY (
		SELECT TOP (1) gn.num + 1 AS numeq FROM nums gn 
		WHERE  gn.num <= 10  AND DATENAME(WEEKDAY, DATEFROMPARTS(YEAR(mmd.min_date) + mmd.num, 4, gn.num)) = 'Monday'
		ORDER BY DATEFROMPARTS(YEAR(mmd.min_date) + mmd.num, 4, gn.num)
	) AS gn2
)
SELECT b.name, CONVERT(date, b.date,20), d.dtfromparts FROM Battles b 
CROSS APPLY (
	SELECT TOP(1) * FROM days d
	WHERE b.date < d.dtfromparts
	ORDER BY d.dtfromparts ASC
	) AS d
```
 Задание: 119 ($erges: 2008-04-25)
Сгруппировать все окраски по дням, месяцам и годам. Идентификатор каждой группы должен иметь вид "yyyy" для года, "yyyy-mm" для месяца и "yyyy-mm-dd" для дня.
Вывести только те группы, в которых количество различных моментов времени (b_datetime), когда выполнялась окраска, более 10.
Вывод: идентификатор группы, суммарное количество потраченной краски.
```sh
WITH resultset AS (
SELECT
	 CASE GROUPING_ID(YEAR(b.B_DATETIME),MONTH(b.B_DATETIME),DAY(b.B_DATETIME)) 
	 -- WHEN 1 then DAY is NULL then grouping by year and month 
		WHEN 0 THEN 
		CONCAT(YEAR(b.B_DATETIME),'-',CASE WHEN MONTH(b.B_DATETIME) < 10 THEN '0' ELSE NULL END, MONTH(b.B_DATETIME), '-',
			CASE WHEN DAY(b.B_DATETIME) < 10 THEN '0' ELSE NULL END, DAY(b.B_DATETIME))
		WHEN 1 THEN CONCAT(YEAR(b.B_DATETIME),'-',CASE WHEN MONTH(b.B_DATETIME) < 10 THEN '0' ELSE NULL END, MONTH(b.B_DATETIME))
		WHEN 3 THEN CAST(YEAR(b.B_DATETIME) AS varchar)
	 END AS dt,
SUM(b.B_VOL) AS vol, COUNT(DISTINCT b.b_DATETIME) AS cnt   FROM utB b
GROUP BY GROUPING SETS
(
	(YEAR(b.B_DATETIME)), --by year
	(YEAR(b.B_DATETIME), MONTH(b.B_DATETIME)), -- year/month
	(YEAR(b.B_DATETIME), MONTH(b.B_DATETIME), DAY(b.B_DATETIME))
)
)
SELECT r.dt, r.vol FROM resultset r
WHERE r.cnt > 10
```
Задание: 120 (mslava: 2004-01-05)
Для каждой авиакомпании, самолеты которой перевезли хотя бы одного пассажира, вычислить с точностью до двух десятичных знаков средние величины времени нахождения самолетов в воздухе (в минутах). Также рассчитать указанные характеристики по всем летавшим самолетам (использовать слово 'TOTAL').
Вывод: компания, среднее арифметическое, среднее геометрическое, среднее квадратичное, среднее гармоническое.

Для справки:

среднее арифметическое = (x1 + x2 + ... + xN)/N

среднее геометрическое = (x1 * x2 * ... * xN)^(1/N)

среднее квадратичное = sqrt((x1^2 + x2^2 + ... + xN^2)/N)

среднее гармоническое = N/(1/x1 + 1/x2 + ... + 1/xN)
```sh
With t as
(Select ID_comp, convert(numeric(18,2), Case when time_in > = time_out
    Then datediff(minute, time_out, time_in)
    Else datediff(minute, time_out, dateadd(day, 1, time_in))
   End) as trmin
From (Select trip_no
 From Pass_in_trip
 Group by trip_no, [date]) pt join Trip t on pt.trip_no = t.trip_no
)

Select Coalesce(c.name, 'TOTAL'), A_mean, G_mean, Q_mean, H_mean
From (
 Select Id_comp ,
  convert(numeric(18,2), avg(trmin)) A_mean,
  convert(numeric(18,2), Exp(avg(Log(trmin)))) G_mean,
  convert(numeric(18,2), sqrt(avg(trmin*trmin))) Q_mean,
  convert(numeric(18,2), count(*)/sum(1/trmin)) H_mean
 From t
 Group by ID_comp
 with cube) as a left join Company c on a.ID_comp = c.ID_comp
```
Задание: 121 (Serge I: 2009-04-17)
Для каждого корабля из таблицы Ships указать название первого по времени сражения из таблицы Battles,
в котором корабль мог бы участвовать после спуска на воду. Если год спуска на воду неизвестен, взять последнее по времени сражение.
Если нет сражения, произошедшего после спуска на воду корабля, вывести NULL вместо названия сражения.
Считать, что корабль может участвовать во всех сражениях, которые произошли в год спуска на воду корабля.
Вывод: имя корабля, год спуска на воду, название сражения

Замечание: считать, что не существует двух битв, произошедших в один и тот же день.
```sh
WITH CTE AS (
SELECT s.name, launched,
CASE
WHEN launched IS null
THEN (SELECT MAX(date) FROM Battles)
ELSE MIN(date)
END AS battle_date
FROM Ships s
LEFT JOIN Battles b
ON s.launched <= YEAR(b.date)
GROUP BY s.name, launched
)
SELECT CTE.name, launched, b.name AS battle_name
FROM CTE
LEFT JOIN Battles b
ON CTE.battle_date = b.date
```
Задание: 122 (Serge I: 2003-08-28)
Считая, что первый пункт вылета является местом жительства, найти пассажиров, которые находятся вне дома. Вывод: имя пассажира, город проживания
```sh
WITH aggregate AS
(
SELECT pit.ID_psg, MIN(CONVERT(VARCHAR(8), pit.[date], 112)+CONVERT(VARCHAR(9), t.[time_out], 108)+t.town_from) AS min_town,
MAX(CONVERT(VARCHAR(10), pit.[date], 112)+CONVERT(VARCHAR(9), t.[time_out], 108)+t.town_to) AS max_town
FROM Pass_in_trip pit JOIN Trip t ON t.trip_no = pit.trip_no
GROUP BY pit.ID_psg
)
SELECT p.name,X1.val1 FROM aggregate a
JOIN Passenger p on a.ID_psg = p.ID_psg
CROSS APPLY (VALUES(SUBSTRING(a.min_town, 17, LEN(a.min_town)))) AS X1(val1)
CROSS APPLY (VALUES(SUBSTRING(a.max_town, 17, LEN(a.max_town)))) AS X2(val1)
WHERE X1.val1 <> X2.val1
```
Задание: 123 (Serge I: 2020-01-24)
Рассматривается таблица Product. Упорядоченные по номеру модели принтеры образуют группы (model - номер группы).
В каждую группу (в порядке возрастания) добавляются по одной модели ПК в порядке возрастания номера модели.
После добавления ПК в последнюю группу процесс продолжается с первой группы до тех пор, пока не закончатся модели ПК.
Выполнить нумерацию в порядке по возрастанию: принтеры по номеру группы, затем модели ПК в группе.
Вывод: номер по порядку, model, type
Замечание. Модели ноутбуков не учитывать и не выводить.
```sh
SELECT ROW_NUMBER() OVER(ORDER BY gp, type DESC, model), 
model,
type
FROM (
    SELECT model, type, ROW_NUMBER() OVER(ORDER BY model) AS gp
    FROM Product 
    WHERE type = 'Printer'
    UNION ALL
    SELECT model, type, (ROW_NUMBER() OVER(ORDER BY model)-1)  % (
        SELECT COUNT(model) FROM Product WHERE type = 'Printer'
    )+1 AS gp
    FROM Product
    WHERE type = 'PC'
) CTE
```
Задание: 124 (DimaN: 2004-03-01)
Среди пассажиров, которые пользовались услугами не менее двух авиакомпаний, найти тех, кто совершил одинаковое количество полётов самолетами каждой из этих авиакомпаний. Вывести имена таких пассажиров.
```sh
WITH cte AS
(
SELECT pit.ID_psg, t.ID_comp, COUNT(pit.trip_no) AS num_of_flights FROM Pass_in_trip pit JOIN Trip t ON pit.trip_no = t.trip_no 
GROUP BY pit.ID_psg, t.ID_comp
)
SELECT p.name FROM Passenger p JOIN cte c ON p.ID_psg = c.ID_psg
GROUP BY p.name, p.ID_psg
HAVING COUNT(c.ID_comp) > 1 AND MIN(num_of_flights) = MAX(num_of_flights)
```
Задание: 125 (Serge I: 2003-04-08)
Определить имена разных пассажиров, летевших хотя бы два раза подряд на месте с одним и тем же номером.
```sh
WITH CTE AS (
    SELECT ID_psg, place, 
    MAX(place) OVER(PARTITION BY ID_PSG ORDER BY date, time_out ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)AS prev_place
    FROM Pass_in_trip p
    JOIN Trip t
    ON p.trip_no = t.trip_no
)
SELECT name
FROM CTE
JOIN Passenger p
ON P.ID_psg = CTE.ID_psg
WHERE place = prev_place
GROUP BY p.ID_psg, p.name
```
Задание: 126 (Serge I: 2015-04-17)
Для последовательности пассажиров, упорядоченных по id_psg, определить того,
кто совершил наибольшее число полетов, а также тех, кто находится в последовательности непосредственно перед и после него.
Для первого пассажира в последовательности предыдущим будет последний, а для последнего пассажира последующим будет первый.
Для каждого пассажира, отвечающего условию, вывести: имя, имя предыдущего пассажира, имя следующего пассажира.
```sh
WITH min_max AS (
	SELECT MIN(id_psg) AS min_psg, MAX(id_psg) AS max_psg FROM Passenger
),
data AS
(
SELECT p.ID_psg, p.name, 
	DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) AS cnt, 
	LAG(p.name, 1, (
		SELECT p1.name from Passenger p1 where p1.id_psg = (
			SELECT max_psg FROM min_max)
			)
		) 
	OVER(ORDER by p.id_psg) AS prev, 
	LEAD(p.name, 1, (
		SELECT p1.name from Passenger p1 where p1.id_psg = (
			SELECT min_psg FROM min_max)
			)
		) 
	OVER(ORDER BY p.id_psg) AS nxt  
	FROM Pass_in_trip pit RIGHT JOIN Passenger p ON p.ID_psg = pit.ID_psg
GROUP BY p.ID_psg, p.name
)
SELECT d.name, d.prev, d.nxt FROM data d WHERE cnt = 1
```
Задание: 127 (qwrqwr: 2015-04-24)
Найти округленное до сотых долей среднее арифметическое следующих цен:
1. Цена самых дешевых Laptop-ов от производителей РС с самой низкой скоростью CD;
2. Цена самых дорогих РС от производителей самых дешевых принтеров;
3. Цена самых дорогих принтеров от производителей Laptop-ов с наибольшим объемом памяти.
Замечание: При расчёте среднего отсутствующие цены не учитывать.
```sh
with cte as (select
(select top 1 price
from [dbo].[Laptop] join [dbo].[Product] on [Product].[model] = [Laptop].[model]
where [maker] in (
select maker
from pc join [dbo].[Product] on [Product].[model] = [PC].[model]
where cd = (select min(cd) from pc)) order by price) [1],
(select top 1 price
from [dbo].[PC] join [dbo].[Product] on [Product].[model] = [PC].[model]
where [maker] in (
select maker
from [dbo].[Printer] join [dbo].[Product] on [Product].[model] = [Printer].[model]
where [price] = (select min([price]) from [dbo].[Printer])) order by price desc) [2],
(select top 1 price
from [dbo].[Printer] join [dbo].[Product] on [Product].[model] = [Printer].[model]
where [maker] in (
select maker
from [dbo].[Laptop] join [dbo].[Product] on [Product].[model] = [Laptop].[model]
where [ram] = (select max([ram]) from [dbo].[Laptop])) order by price desc) [3])
select cast(val / iif([ca].[div] = 0, 1, [ca].[div]) as decimal(14, 2))
from cte
cross apply (
select (coalesce([cte].[1], 0) * 1.0 + coalesce([cte].[2], 0) * 1.0 + coalesce([cte].[3], 0) * 1.0) as val,
iif([cte].[1] is null, 0, 1) + iif([cte].[2] is null, 0, 1) + iif([cte].[3] is null, 0, 1) as [div]
from cte) ca
```
Задание: 128 (Shurgenz: 2006-08-05)
Определить лидера по сумме выплат в соревновании между каждой существующей парой пунктов с одинаковыми номерами из двух разных таблиц - outcome и outcome_o - на каждый день, когда осуществлялся прием вторсырья хотя бы на одном из них.
Вывод: Номер пункта, дата, текст:
- "once a day", если сумма выплат больше у фирмы с отчетностью один раз в день;
- "more than once a day", если - у фирмы с отчетностью несколько раз в день;
- "both", если сумма выплат одинакова.
```sh
with
cta as (
select [point], [date], sum(out) s
from outcome
where [point] in (select point from [dbo].[Outcome_o])
group by [point], [date]),

ctb as (
select [point], [date], sum(out) s
from outcome_o
where [point] in (select point from [dbo].[Outcome])
group by [point], [date]),

ctc as (select
	coalesce([cta].[point], ctb.[point]) as point,
	coalesce([cta].[date], [ctb].[date]) as [date],
	coalesce([cta].[s], 0) as [sa],
	coalesce([ctb].[s], 0) as [sb]
from cta full join ctb on [ctb].[date] = [cta].[date] and [ctb].[point] = [cta].[point])
select 
	[ctc].[point],
	[ctc].[date],
	case
		when sa > sb then 'more than once a day'
		when sa < sb then 'once a day'
		else 'both'
	end lider
from ctc
order by [ctc].[point],[ctc].[date]
```
Задание: 129 (Serge I: 2008-02-01)
Предполагая, что среди идентификаторов квадратов имеются пропуски, найти минимальный и максимальный "свободный" идентификатор в диапазоне между имеющимися максимальным и минимальным идентификаторами.
Например, для последовательности идентификаторов квадратов 1,2,5,7 результат должен быть 3 и 6.
Если пропусков нет, вместо каждого искомого значения выводить NULL.
```sh
WITH first_results AS (
SELECT u.Q_ID id, CASE WHEN LEAD(u.Q_ID, 1) OVER (ORDER BY u.Q_ID ASC) <> u.Q_ID + 1 THEN  LEAD(u.Q_ID, 1) OVER (ORDER BY u.Q_ID ASC) ELSE NULL END AS nxt_num  FROM utQ u
), resultset AS (
	SELECT r.id + 1 as prev, r.nxt_num - 1 as nxt from first_results r
	WHERE r.nxt_num IS NOT NULL
)
SELECT MIN(r.prev), MAX(r.nxt) FROM resultset r
```
Задание: 130 (Velmont: 2015-08-14)
Историки решили составить отчет о битвах в два суперстолбца. Каждый суперстолбец состоит из трёх столбцов (номер битвы, название и дата).
Сначала в порядке возрастания номеров заполняется первый суперстолбец, потом - второй. Порядковый номер битве назначается согласно сортировке: дата, название.
С целью экономии бумаги, историки делят информацию из таблицы Battles поровну, занося в первый суперстолбец на одну битву больше при их нечетном количестве.
В таблицу с шестью колонками вывести результат работы историков, пустые места заполнить NULL-значениями.
```sh
WITH numbered_battles AS
(
	SELECT b.name, b.date, ROW_NUMBER() OVER(ORDER BY b.date ASC, b.name ASC) as rn, d.cnt
	FROM Battles b CROSS JOIN (Select COUNT(*) FROM Battles) as d(cnt)
), grouped_battles AS
(
	SELECT name, date, rn,cnt, grp, ROW_NUMBER() OVER(PARTITION BY grp ORDER BY rn) AS rn_1 FROM (
		SELECT name, date, rn,cnt, 
		-- CASE --
		CASE cnt%2
			WHEN 0 THEN
				CASE WHEN rn <= cnt / 2 THEN 1 ELSE 2 END
			WHEN 1 THEN 
				CASE WHEN rn <= CEILING(CAST(cnt AS numeric(10,2)) / 2) THEN 1 ELSE 2 END
		END as grp
		FROM numbered_battles
	) AS d
)
SELECT d1.rn, d1.name, d1.date, d2.rn, d2.name, d2.date FROM (SELECT name, date, rn, grp, rn_1 FROM grouped_battles g WHERE grp = 1) AS d1
LEFT JOIN (SELECT name, date, rn, grp, rn_1 FROM grouped_battles g WHERE grp = 2) AS d2
ON d1.rn_1 = d2.rn_1
```
Задание: 131 (qwrqwr: 2010-09-24)
Выбрать из таблицы Trip такие города, названия которых содержат минимум 2 разные буквы из списка (a,e,i,o,u) и все имеющиеся в названии буквы из этого списка встречаются одинаковое число раз.
```sh
with ctea as (
select distinct town_from [town] from [dbo].[Trip] union select town_to from [dbo].[Trip]),
cteb as (select 'a' s union all select 'e' union all select 'i' union all select 'o' union all select 'u'),
ctec as (
select [town], DATALENGTH([ctea].[town]) - DATALENGTH(replace([ctea].[town], s, '')) as cs
from ctea, cteb),
ctee as (select [town], [cs], count(*) over(partition by [ctec].[town]) cc,
max(cs)  over(partition by [ctec].[town]) mxc, min(cs) over(partition by [ctec].[town]) mnc
from ctec where cs > 0)
select distinct town from ctee where cc > 1 and mxc = mnc
```
Задание: 132 (pаparome: 2005-12-02)
Предполагая, что не существует номера рейса большего 65535,
вывести номер рейса и его представление в двоичной системе счисления (без ведущих нулей)
```sh
with cte as (select trip_no,
                    cast(trip_no as integer) num,
                    cast('' as varchar(max)) str
             from trip
             union all
             select trip_no, num / 2, concat(num % 2, str)
             from cte
             where num <> 0)
 
select trip_no, str trip_no_bit
from cte
where num = 0
```
Задание: 133 (Serge I: 2006-11-17)
Распределить по трем столбцам (построчно) квадраты из таблицы utq в порядке возрастания их идентификаторов.
Если последняя строка окажется незаполненной, использовать NULL для отсутствующих значений.
Например, для последовательности идентификаторов {1,2,3,4,5,6,7,8} результат должен выглядеть так:

1   2   3

4   5   6

7   8   NULL
```sh
with tab as (select q_id, (num - 1) % 3 c_num, (num - 1) / 3 r_num
             from (select q_id, row_number() over(order by q_id) num
                   from utq) a)
 
select t1.q_id X, t2.q_id Y, t3.q_id Z
from (select *
      from tab
      where c_num = 0) t1
    left join (select *
               from tab
               where c_num = 1) t2 on t2.r_num = t1.r_num
    left join (select *
               from tab
               where c_num = 2) t3 on t3.r_num = t1.r_num
```
Задание: 134 (Serge I: 2003-12-26)
Выполняется докраска квадратов до белого цвета каждым цветом по следующей схеме:
- сначала закрашиваются квадраты, для которых требуется меньше краски соответствующего цвета;
- при одинаковом необходимом количестве краски сначала закрашиваются квадраты с меньшим q_id.
Найти идентификаторы НЕ белых квадратов, оставшихся после израсходования всей краски.
```sh
WITH CTE AS (
    SELECT Q_ID,
    255 - SUM(CASE WHEN V_COLOR = 'R' AND B_VOL IS NOT NULL THEN B_VOL ELSE 0 END) AS r_need,
    255 - SUM(CASE WHEN V_COLOR = 'G' AND B_VOL IS NOT NULL THEN B_VOL ELSE 0 END) AS g_need,
    255 - SUM(CASE WHEN V_COLOR = 'B' AND B_VOL IS NOT NULL THEN B_VOL ELSE 0 END) AS b_need
    FROM utB b
    JOIN utV v
    ON b.B_V_ID = v.V_ID
    RIGHT JOIN utQ q
    ON b.B_Q_ID = Q.Q_ID
    GROUP BY Q_ID
),
CTE2 AS (
    SELECT V_ID, V_COLOR, 255 - SUM(CASE WHEN B_VOL IS NOT NULL THEN B_VOL ELSE 0 END) AS leftover
    FROM utB b
    RIGHT JOIN utV v
    ON b.B_V_ID = v.V_ID
    GROUP BY V_ID, V_COLOR
),

CTE3 AS (
    SELECT DISTINCT SUM(CASE V_COLOR WHEN 'R' THEN leftover ELSE 0 END) OVER() AS r_leftover, 
    SUM(CASE V_COLOR WHEN 'G' THEN leftover ELSE 0 END) OVER() AS g_leftover, 
    SUM(CASE V_COLOR WHEN 'B' THEN leftover ELSE 0 END) OVER() AS b_leftover
    FROM CTE2
),
CTE4 AS (
    SELECT Q_ID, 
    SUM(r_need) OVER(ORDER BY r_need, Q_ID ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS r_nd,
    SUM(g_need) OVER(ORDER BY g_need, Q_ID ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS g_nd,
    SUM(b_need) OVER(ORDER BY b_need, Q_ID ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS b_nd
    FROM CTE
)
```
Задание: 135 (Serge I: 2016-12-16)
В пределах каждого часа, в течение которого выполнялись окраски,
найти максимальное время окраски (B_DATETIME).
```sh
SELECT MAX(b_datetime) FROM utB
GROUP BY CAST(CONVERT(varchar, b_datetime, 112) + ' '+LEFT(CONVERT(varchar, B_DATETIME, 114), 2) + ':00' AS datetime2)
-- Forgot about DATEPART function
SELECT MAX(b_datetime) FROM utB
GROUP BY CAST(B_DATETIME AS date), DATEPART(HOUR, B_DATETIME)
```
Задание: 136 (Serge I: 2017-01-13)
Для каждого корабля из таблицы Ships, в имени которого есть символы, не являющиеся латинской буквой, вывести:
имя корабля, позиционный номер первого небуквенного символа в имени и сам символ.
```sh
SELECT name, 
       PATINDEX('%[^a-zA-Z]%', name) as position, 
       SUBSTRING(name, PATINDEX('%[^a-zA-Z]%', name), 1) as non_alpha_char
FROM Ships
WHERE PATINDEX('%[^a-zA-Z]%', name) > 0
```
Задание: 137 (Serge I: 2005-01-19)
Для каждой пятой модели (в порядке возрастания номеров
моделей) из таблицы Product
определить тип продукции и среднюю цену модели.
```sh
with all_models AS
(
	SELECT model, price FROM PC
	UNION ALL 
	SELECT model, price FROM Printer
	UNION ALL 
	SELECT model, price FROM Laptop
), grouped_models AS 
(
	SELECT p.model, MAX(p.type) as type, AVG(a.price) as avg_price FROM Product p LEFT JOIN all_models a ON p.model = a.model
GROUP BY p.model
), numbered AS
(
	SELECT model, type, avg_price, ROW_NUMBER() OVER(Order by model ASC) as rn FROM grouped_models
)
SELECT TYPE, avg_price FROM numbered WHERE rn % 5 = 0
```
Задание: 138 (Kursist: 2021-10-15)
Выведите имена пассажиров, которые побывали в наибольшем количестве разных городов, включая города отправления.
```sh
WITH CTE AS (
    SELECT pit.ID_psg, town_from, town_to, name
    FROM Trip t
    JOIN Pass_in_trip pit
    ON t.trip_no = pit.trip_no
    JOIN Passenger p
    ON p.ID_psg = pit.ID_psg
),
CTE2 AS (
    SELECT ID_psg, town_from AS town, name
    FROM CTE
    UNION
    SELECT ID_psg, town_to AS town, name
    FROM CTE
),
CTE3 AS (
    SELECT name, COUNT(DISTINCT town) AS num
    FROM CTE2
    GROUP BY ID_psg, name
)
SELECT name 
FROM CTE3
WHERE num = (
    SELECT MAX(num) FROM CTE3
)
```
Задание: 139 (Kursist: 2021-11-13)
Выведите страны, корабли которых не участвовали ни в одной битве.
```sh
WITH CTE AS (
    SELECT DISTINCT country, ship
    FROM Classes c
    LEFT JOIN Ships s
    ON c.class = s.class
    JOIN Outcomes o
    ON o.ship = s.name OR o.ship = c.class
)
SELECT DISTINCT country
FROM Classes c
WHERE NOT EXISTS (
    SELECT 1
    FROM CTE
    WHERE c.country = CTE.country
)
```
Задание: 140 (no_more: 2017-07-07)
Определить, сколько битв произошло в течение каждого десятилетия, начиная с даты первого сражения в базе данных и до даты последнего.
Вывод: десятилетие в формате "1940s", количество битв.
```sh
WITH nums1 AS (select 1 as n from (values(1),(1),(1),(1),(1),(1)) as d(n))
, nums2 AS (SELECT 1 as n FROM nums1 n1 CROSS JOIN nums1 n2)
, rns AS (SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) as rn FROM nums2)
, max_yrs AS (
	SELECT MIN(DATEPART(year, date)/10)*10 as min_yr, MAX(DATEPART(year, date)/10)*10 as max_yr FROM Battles
), gen_decades AS 
(
	SELECT min_yr + (rn - 1) * 10  AS yr  FROM max_yrs JOIN rns ON min_yr + (rn - 1) * 10 <= max_yr
)
SELECT CAST(gd.yr AS varchar(4)) + 's', COUNT(b.name) FROM gen_decades gd LEFT JOIN Battles b ON gd.yr = (DATEPART(year, b.date)/10)*10
GROUP BY gd.yr
```
Задание: 141 (Serge I: 2017-11-03)
Для каждого из летавших пассажиров определить количество дней в апреле 2003 года, попавших в интервал между датами первого и последнего вылета пассажира включительно.
Вывести имя пассажира и количество дней.
```sh
WITH min_maxes AS
(
	SELECT pit.ID_psg, MIN(pit.[date]) AS min_dt, MAX(pit.[date]) AS max_dt FROM Pass_in_trip pit
	GROUP BY pit.ID_psg
), dates_of_interest AS
(
	SELECT  mm.ID_psg, mm.min_dt, mm.max_dt, CASE WHEN 
		(mm.min_dt BETWEEN '20030401' AND '20030430') OR (mm.max_dt BETWEEN '20030401' AND '20030430')
		OR (mm.min_dt < '20030401' AND mm.max_dt > '20030430') THEN 1 ELSE 0 END AS flag
		FROM min_maxes mm
)
SELECT p.name, X.val AS cnt 
FROM dates_of_interest doi JOIN Passenger p ON doi.ID_psg = p.ID_psg
CROSS APPLY 
	(
		VALUES(CASE WHEN doi.flag = 1 THEN (DATEDIFF(DAY, CASE WHEN doi.min_dt < '20030401' THEN '20030401' ELSE doi.min_dt END , CASE WHEN doi.max_dt > '20030430' THEN '20030430' ELSE doi.max_dt END ) + 1) ELSE 0 END) 
	) AS X(val)
```
 Задание: 142 (Serge I: 2003-08-28)
Среди пассажиров, летавших на самолетах только одного типа, определить тех, кто прилетал в один и тот же город не менее 2-х раз.
Вывести имена пассажиров.
```sh
SELECT name FROM Passenger p
WHERE p.ID_psg IN (
	SELECT pit.Id_psg FROM Pass_in_trip pit JOIN Trip t ON pit.trip_no = t.trip_no
		GROUP BY pit.ID_psg
	HAVING MAX(t.plane) = MIN(t.plane) AND COUNT(*) - COUNT(DISTINCT t.town_to) >= 1
)
```
Задание: 143 (Serge I: 2011-10-08)
Для каждого сражения определить день, являющийся последней пятницей месяца, в котором произошло данное сражение.
Вывод: сражение, дата сражения, дата последней пятницы месяца.
Даты представить в формате "yyyy-mm-dd"
```sh
WITH nums AS
(
	SELECT 0 AS n
	UNION ALL
	SELECT n + 1 AS n FROM nums
	WHERE n < 6
)
SELECT b.name, CAST(b.date AS date), DATEADD(day, -n , EOMONTH(b.date)) FROM Battles b JOIN Nums n
ON DATEPART(dw, DATEADD(day, -n , EOMONTH(b.date))) = DATEPART(dw, '20210326')
```
Задание: 144 (Serge I: 2019-01-04)
Найти производителей, которые производят PC как с самой низкой ценой, так и с самой высокой.
Вывод: maker
```sh
WITH all_1 AS
(
	SELECT p.maker, p.model, pc.price FROM Product p JOIN PC pc ON p.model = pc.model
), min_max AS
(
	SELECT MIN(price) as minp, MAX(price) as maxp FROM PC
)
SELECT a1.maker FROM all_1 a1
WHERE a1.price = (SELECT minp FROM min_max)
INTERSECT
SELECT a1.maker FROM all_1 a1
WHERE a1.price =(SELECT maxp FROM min_max)
```
Задание: 145 (Serge I: 2019-01-04)
Для каждой пары последовательных дат, dt1 и dt2, поступления средств (таблица Income_o) найти сумму выдачи денег (таблица Outcome_o) в полуоткрытом интервале (dt1, dt2].
Вывод: сумма, левая граница интервала, правая граница интервала.
```sh
WITH CTE AS (
    SELECT DISTINCT date, DENSE_RANK() OVER(ORDER BY date) AS rn
    FROM Income_o
),
CTE2 AS (
    SELECT c1.date AS start_date,
    c2.date AS end_date
    FROM CTE c1
    JOIN CTE c2
    ON c1.rn = c2.rn - 1
)
SELECT SUM(COALESCE(out,0)),start_date, end_date
FROM CTE2 c2
LEFT JOIN Outcome_o o
ON o.date > start_date AND o.date <= end_date
GROUP BY start_date, end_date
```
Задание: 146 (Serge I: 2008-08-30)
Для ПК с максимальным кодом из таблицы PC вывести все его характеристики (кроме кода) в два столбца:
- название характеристики (имя соответствующего столбца в таблице PC);
- значение характеристики
```sh
WITH cte AS
(
	SELECT TOP (1) CAST(pc.cd AS VARCHAR(50)) cd, CAST(pc.hd AS VARCHAR(50)) hd, CAST(pc.model AS VARCHAR(50)) model,
	CAST(pc.price AS VARCHAR(50)) price, CAST(pc.ram AS VARCHAR(50)) ram, CAST(pc.speed AS VARCHAR(50)) speed
	FROM PC pc
	ORDER BY code DESC
)
SELECT chr, value FROM cte c
CROSS APPLY (VALUES('cd', [cd]), ('hd', [hd]), ('model', [model]), ('price', [price]), ('ram', [ram]), ('speed', [speed])) AS X(chr, value)
```
Задание: 147 (Serge I: 2011-02-11)
Пронумеровать строки из таблицы Product в следующем порядке: имя производителя в порядке убывания числа производимых им моделей (при одинаковом числе моделей имя производителя в алфавитном порядке по возрастанию), номер модели (по возрастанию).
Вывод: номер в соответствии с заданным порядком, имя производителя (maker), модель (model)
```sh
WITH cnts AS
(
	SELECT p.maker, COUNT(*) AS cnt FROM Product p
	GROUP BY p.maker
)
SELECT ROW_NUMBER() OVER( ORDER BY c.cnt DESC, p.maker ASC, p.model ASC ), p.maker, p.model FROM Product p JOIN cnts c ON p.maker = c.maker
```
Задание: 148 (Serge I: 2009-08-11)
Для таблицы Outcomes преобразовать названия кораблей, содержащих более одного пробела, следующим образом.
Заменить все символы между первым и последним пробелами (исключая сами эти пробелы) на символы звездочки (*)
в количестве, равном числу замененных символов.
Вывод: название корабля, преобразованное название корабля
```sh
WITH cte AS (
	SELECT o.ship, occ_1st_space.sp as frst_occ, occ_lst_space.sp AS lst_occ, LEN(o.ship) as ln FROM Outcomes o
	CROSS APPLY (VALUES
					(CHARINDEX(' ', o.ship, 1))
		) AS occ_1st_space(sp)
	CROSS APPLY (
		VALUES(
			DATALENGTH(o.ship) - CHARINDEX(' ', REVERSE(o.ship), 1 ) + 1
			)
		) AS occ_lst_space(sp)
	WHERE NOT (occ_1st_space.sp = occ_lst_space.sp OR occ_1st_space.sp = 0 OR occ_lst_space.sp = 0)
)
SELECT c.ship, STUFF(c.ship, c.frst_occ + 1, c.lst_occ - 1 - c.frst_occ , REPLICATE('*', c.lst_occ - 1 - c.frst_occ)) FROM cte c
```
Задание: 149 (Kursist: 2019-06-28)
Найти минимальную верхнюю границу интервала ( MinTime >= B_DATETIME), в течение которого каждый из баллончиков в таблице UTB был использован хотя бы один раз.
Вывести названия разных баллончиков, которые принимали участие в окраске в момент MinTime.
```sh
WITH CTE AS (
    SELECT b1.B_DATETIME 
    FROM UTB b1
    JOIN UTB b2
    ON b1.B_DATETIME >= b2.B_DATETIME
    GROUP BY b1.B_DATETIME
    HAVING COUNT(DISTINCT b2.B_V_ID) = (
        SELECT COUNT(DISTINCT B_V_ID) FROM UTB
    )
)
SELECT v.V_NAME
FROM UTB b
JOIN UTV v
ON b.B_V_ID = v.V_ID
WHERE b.B_DATETIME = (
    SELECT MIN(B_DATETIME) 
    FROM CTE
)
GROUP BY v.V_ID, v.V_NAME
```
Задание: 150 (Serge I: 2019-07-05)
Для каждого пункта в таблице income определить минимальную (min_date) и максимальную (max_date) даты поступления средств.
В упорядоченной по времени последовательности всех записей в таблице income для каждого интервала [min_date, max_date]
определить по одной строке непосредственно выше (date1 < min_date) и непосредственно ниже (date2 > max_date).
Другими словами, требуется расширить каждый интервал на одну строку сверху и снизу. Если искомой строки/строк нет, считать значение date1/date2 неопределенным (NULL).
Вывод: point, date1, min_date, max_date, date2.
```sh
WITH CTE AS (
    SELECT point, 
    date,
    DENSE_RANK() OVER(PARTITION BY point ORDER BY date) AS min_rn,
    DENSE_RANK() OVER(PARTITION BY point ORDER BY date DESC) AS max_rn,
    DENSE_RANK() OVER(ORDER BY date) AS rn
    FROM Income
)
SELECT DISTINCT c1.point, c3.date, c1.date, c2.date, c4.date
FROM CTE c1
JOIN CTE c2
ON c1.point = c2.point
LEFT JOIN CTE c3
ON c3.rn = c1.rn - 1
LEFT JOIN CTE c4
ON c4.rn = c2.rn + 1
WHERE c1.min_rn = 1 AND c2.max_rn = 1
```
